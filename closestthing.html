<!DOCTYPE html>
<html>
	<head>
	<style>
	body {background-color:black;}
	label  {color:red;}
	p    {color:green;}
	</style>
		<title>Javascript</title>
	<meta charset="utf-8" />
    <script src="Scripts/jquery-2.2.2.min.js"></script>
    <script src="http://cpettitt.github.io/project/graphlib/latest/graphlib.js"></script>
    <script src="http://cpettitt.github.io/project/graphlib/latest/graphlib.min.js"></script>
	<script src="Scripts/cytoscape.js"></script>
	<script src="Scripts/cytoscape.min.js"></script>

		</head>
		<body>

		<label><b> <ins>Hi!</ins></b></label>
	<br/>
	<label>Upload your stuff:</label>
    <input type="file" accept=".json" id="ourFile"/>
	<input type="button" value="Parse" onclick="main_func()"/> 

	<br/>
	 

	
		<script type="text/javascript"> 

		function main_func(){
			var bytes = document.getElementById("ourFile");
			var reader = new FileReader();

			reader.readAsText(bytes.files[0]);
			reader.onload = function()
			{

				var text = reader.result; //the letters of the file are in this variable
				var json = JSON.parse(text); //here we have the json objects we just need to index them correctly

				var ModuleNames = []; //the names of all our modules
				var ModuleCount = 0;//how many modules we have (might be useful, so why not lol)
				for(property in json.modules) //here we're gonna know how many modules are in our top module, and their names will be stored in property
				{
					document.write("<br>", "=== Analyzing Module: ", property, " ===<br>");
					var traverse_ports = json.modules[property]["ports"];
					var Inputs = [];
					var Outputs = [];
					var InputCount = 0;
					var OutputCount = 0;
					var arrow = " â†’ ";
					for(port in traverse_ports) //so here we are in the ports. we have an array of inputs and outputs. each of these we will push inside their: 
						//name: their actual name
						//bits: what JSON identifies them with...will be usful in connections
						//type: is it an input or output?
						//you can reference this by going Input[i].name, type whatever.
					{
						document.write("<br>", "Analyzing port: ", port, "<br>");
						if (traverse_ports[port]["direction"] == "input") {
							Inputs.push({
								name: port,
								bits: traverse_ports[port]["bits"],
								type: 'input',
								connections: []
							});
							document.write("Port: ", Inputs[InputCount].name, " is an: ", Inputs[InputCount].type, "<br>" );
							InputCount++;
						}
						else
							if (traverse_ports[port]["direction"] == "output")
							{

								Outputs.push({
									name: port,
									bits: traverse_ports[port]["bits"],
									type: 'output'
								});

								
								document.write("Port: ", Outputs[OutputCount].name, " is an ", Outputs[OutputCount].type, "<br>");
								OutputCount++;

							}
					}

					var theCells = json.modules[property]["cells"];
					var Celliez = [];
					//our array celliez will have all of the cells. their names will be in .name, there is an array of connections that has all of the "bits" of the inputs and outputs connected to them.
					//variable amount has how many of those are. connections[amount-1] is the output. all the rest are input..that's why i didn't make the name an object literal so that it doesn't get too confusing
					var CellsCount = 0;

					for(cell in theCells){
						
						var connects = theCells[cell]["connections"];
						var conny_per_gate = [];
						var IOCount = 0;
						for(conny in connects){
							conny_per_gate.push(connects[conny]);

							IOCount++;

						}
						//add here the made array for connections in celliez of [howmnaycells]
						Celliez.push({
							name: theCells[cell]["type"],
							connections: conny_per_gate,
							amount: IOCount, //note that connections[amount-1] is an output. everything before then is an input
							output: conny_per_gate[IOCount-1]

						});
						document.write("<br> ", "cell: ", Celliez[CellsCount].name, " has the following connections: <br>");
						for (var ii= 0; ii < Celliez[CellsCount].amount; ii++) {

							document.write(Celliez[CellsCount].connections[ii], "<br>");
						}
						document.write("its output is on port: ", Celliez[CellsCount].output, "<br>");
						CellsCount++;
					}
				}

				//here we are left with an array of our inputs, array of our gates with all their connections. we need an algorithm to identify the paths. 

				//we will check, for every input. if it's connected to any of our cells. if it is, an edge exists between that input and that cell.

				//what idk how to do, is checking what THAT cell is connected to. even though we know it's output identifier is stored in Celliez[at it's index].connections[amount-1]

				var DAG = new graphlib.graph({directed: true});

				for (var input_i = 0; input_i < Inputs.length; input_i++) {
					for (var cell_i = 0; cell_i < Celliez.length; cell_i++) {
						for (var cell_con_i =0; cell_con_i < Celliez[cell_i].amount; cell_con_i++) {
							/*
						document.write("Checking cell: ", Inputs[input_i].bits, " against connect ", Celliez[cell_i].connections[cell_con_i], " in cell: ",Celliez[cell_i].name); */
						if (Inputs[input_i].bits.toString() == Celliez[cell_i].connections[cell_con_i].toString()) {

							//ok so we put our name for our thing..and we asscoaite it with our struct data structure itsself for our usages.
							DAG.setNode(Inputs[input_i].name, Inputs[input_i]);
							DAG.setNode(Celliez[cell_i].name, Celliez[cell_i]);

							DAG.setEdge(Inputs[input_i].name, Celliez[cell_i].name);

							document.write("Path: ", Inputs[input_i].name, arrow, Celliez[cell_i].name, "<br>");
						}

					}

					}
				}

				//we checked each input is going to what...now what is the what going to?
				for(var outcell = 0; outcell < Celliez.length ; outcell++){
				for (var cell_i = outcell+1; cell_i <= Celliez.length -1; cell_i++) {
						for (var cell_con_i =0; cell_con_i < Celliez[cell_i].amount; cell_con_i++) {

							if (Celliez[outcell].output.toString() == Celliez[cell_i].connections[cell_con_i].toString()) {

								DAG.setNode(Celliez[cell_i].name);

								DAG.setEdge(Celliez[outcell].name, Celliez[cell_i].name);

								document.write(Celliez[outcell].name, arrow, Celliez[cell_i].name ,"<br>");
							}
							
							}

						}


					}


				for (var output_i = 0; output_i < Outputs.length; output_i++) {
					for (var cell_i = 0; cell_i < Celliez.length; cell_i++) {

							/*
						document.write("Checking cell: ", Inputs[input_i].bits, " against connect ", Celliez[cell_i].connections[cell_con_i], " in cell: ",Celliez[cell_i].name); */
						if (Outputs[output_i].bits.toString() == Celliez[cell_i].output.toString()) {

							//ok so we put our name for our thing..and we asscoaite it with our struct data structure itsself for our usages.
							DAG.setNode(Outputs[output_i].name, Outputs[output_i]);

							DAG.setEdge(Celliez[cell_i].name, Outputs[output_i].name);

							document.write(Celliez[cell_i].name, arrow,Outputs[output_i].name,  "<br>");
						}
					}
				}

				var trav = graphlib.alg.components(DAG);
	
				document.write(trav[0], " <br> ");
				
			}

		};

		</script>
		</body>
</html>
